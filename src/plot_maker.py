import csvfrom pathlib import Pathfrom typing import Dict, Optional, List, Any, Tupleimport matplotlibmatplotlib.use("Agg")import matplotlib.pyplot as pltimport matplotlib.image as mpimgfrom matplotlib.backends.backend_pdf import PdfPages# ----------------------------# Your heads (rows)# ----------------------------HEAD_LAYER_PLOTS = [    (18, 24), (19, 16), (18, 11), (18, 26), (16, 2),    (18, 13), (21, 14), (18, 16), (18, 27), (20, 23),    (22, 9), (17, 0),]# ----------------------------# Column order# ----------------------------LABELS = ["TP", "FP", "FN", "TN"]COL_HEADERS = [    "Bind TP", "Bind FP", "Bind FN", "Bind TN",    "NoBind TP", "NoBind FP", "NoBind FN", "NoBind TN",]# ----------------------------# A SERIES of example dicts (each one produces one panel)# ----------------------------EXAMPLE_SERIES: List[Dict[str, Any]] = [    {        "name": "set_00",        "examples": {            "with_binding": {            "TP": "pair_00000_with",            "FP": "pair_00000_without",            "FN": "pair_00002_with",            "TN": "pair_00002_without",            },            "without_binding": {                "TP": "pair_00000_with",                "FP": "none",  # <- no FP available                "FN": "pair_00069_with",                "TN": "pair_00069_without",            },        },    },    {        "name": "set_01",        "examples": {            "with_binding": {                "TP": "pair_00025_with",                "FP": "pair_00025_without",                "FN": "pair_00026_with",                "TN": "pair_00026_without",            },            "without_binding": {                "TP": "pair_00001_with",                "FP": "none",  # <- no FP available                "FN": "pair_00085_with",                "TN": "pair_00085_without",            },        },    },    {        "name": "set_02",        "examples": {            "with_binding": {                "TP": "pair_00001_with",                "FP": "pair_00001_without",                "FN": "pair_00006_with",                "TN": "pair_00006_without",            },            "without_binding": {                "TP": "pair_00002_with",                "FP": "none",  # <- no FP available                "FN": "pair_00092_with",                "TN": "pair_00092_without",            },        },    },    {        "name": "set_03",        "examples": {            "with_binding": {                "TP": "pair_00007_with",                "FP": "pair_00007_without",                "FN": "pair_00018_with",                "TN": "pair_00018_without",            },            "without_binding": {                "TP": "pair_00003_with",                "FP": "none",  # <- no FP available                "FN": "pair_00107_with",                "TN": "pair_00107_without",            },        },    },    {        "name": "set_04",        "examples": {            "with_binding": {                "TP": "pair_00014_with",                "FP": "pair_00014_without",                "FN": "pair_00023_with",                "TN": "pair_00023_without",            },            "without_binding": {                "TP": "pair_00004_with",                "FP": "none",  # <- no FP available                "FN": "pair_00069_with",                "TN": "pair_00069_without",            },        },    },]# Where your two big folders liveROOTS = {    "with_binding": Path("with_binding"),    "without_binding": Path("without_binding"),}# per_case.csv filename (lives directly under each ROOTS[dataset])PER_CASE_CSV = "reports\per_case.csv"# Output folder (one PNG per panel)OUT_DIR = Path("reports/attention_panels")# Optional combined PDF (one panel per page)OUT_PDF = Path("reports/attention_panels/all_panels.pdf")# If True: raise error on mismatch/missing in per_case.csv. If False: warn + annotate.STRICT_SANITY = Truedef find_single_subdir(p: Path) -> Optional[Path]:    """Inside pair folder there is one random-named subfolder. Return that subfolder."""    if not p.exists():        return None    subs = sorted([x for x in p.iterdir() if x.is_dir()])    return subs[0] if subs else Nonedef load_image(path: Path):    try:        return mpimg.imread(str(path))    except Exception:        return Nonedef overlay_path(dataset: str, pair_folder: str, layer: int, head: int) -> Optional[Path]:    """    Build:      <ROOT>/<dataset>/reports/figs/<pair_folder>/<random_subdir>/L{layer}_H{head}_overlay.png    """    root = ROOTS[dataset]    pair_dir = root / "reports" / "figs" / pair_folder    sub = find_single_subdir(pair_dir)    if sub is None:        return None    p = sub / f"L{layer}_H{head}_overlay.png"    return p if p.exists() else Nonedef _stem_from_csv_path(s: str) -> str:    # e.g. "data/images/pair_00020_with.png" -> "pair_00020_with"    return Path(s.strip()).stemdef load_per_case_labels(dataset: str) -> Dict[str, str]:    """    Reads <ROOT>/<dataset>/per_case.csv and returns:      { "pair_00020_with": "TP", "pair_00020_without": "TN", ... }    Assumes last 4 columns are one-hot ints for [TP, FP, FN, TN].    """    csv_path = ROOTS[dataset] / PER_CASE_CSV    if not csv_path.exists():        raise FileNotFoundError(f"Missing per-case file: {csv_path}")    mapping: Dict[str, str] = {}    with csv_path.open("r", newline="") as f:        reader = csv.reader(f)        for row in reader:            if not row:                continue            # first column is image path            key = _stem_from_csv_path(row[0])            if len(row) < 4:                continue  # malformed            # last 4 columns should be TP,FP,FN,TN flags            last4 = row[-4:]            try:                flags = [int(x) for x in last4]            except ValueError:                # if header or weird line, skip                continue            if sum(flags) != 1:                # ambiguous/unknown; skip but keep note if you want                continue            label = LABELS[flags.index(1)]            mapping[key] = label    return mappingdef sanity_check_examples(    examples: Dict[str, Dict[str, str]],    label_maps: Dict[str, Dict[str, str]],) -> List[str]:    """    Returns a list of human-readable issues for mismatches/missing.    """    issues: List[str] = []    for dataset in ("with_binding", "without_binding"):        for expected_label in LABELS:            pair_folder = examples.get(dataset, {}).get(expected_label, "none")            if pair_folder is None or str(pair_folder).lower() == "none":                continue            true_label = label_maps.get(dataset, {}).get(pair_folder)            if true_label is None:                issues.append(                    f"[{dataset}] {pair_folder} expected {expected_label} but NOT FOUND in {PER_CASE_CSV}"                )            elif true_label != expected_label:                issues.append(                    f"[{dataset}] {pair_folder} expected {expected_label} but per_case says {true_label}"                )    return issuesdef render_attention_panel(    examples: Dict[str, Dict[str, str]],    out_png: Path,    label_maps: Dict[str, Dict[str, str]],):    rows = len(HEAD_LAYER_PLOTS)    cols = 8    cell = 1.4    fig, axes = plt.subplots(        rows, cols,        figsize=(cell * cols, cell * rows),        constrained_layout=False    )    if rows == 1:        axes = axes.reshape(1, -1)    for r, (layer, head) in enumerate(HEAD_LAYER_PLOTS):        for c in range(cols):            ax = axes[r, c]            ax.set_xticks([])            ax.set_yticks([])            ax.set_frame_on(False)            try:                ax.set_box_aspect(1)            except AttributeError:                ax.set_aspect(1, adjustable="box")            if c < 4:                dataset = "with_binding"                expected_label = LABELS[c]            else:                dataset = "without_binding"                expected_label = LABELS[c - 4]            pair_folder = examples.get(dataset, {}).get(expected_label, "none")            mismatch_note: Optional[str] = None            if pair_folder is not None and str(pair_folder).lower() != "none":                true_label = label_maps.get(dataset, {}).get(pair_folder)                if true_label is None:                    mismatch_note = "NOT IN CSV"                elif true_label != expected_label:                    mismatch_note = f"CSV={true_label}"            # draw image (or blank)            if pair_folder is None or str(pair_folder).lower() == "none":                pass            else:                p = overlay_path(dataset, pair_folder, layer, head)                if p is None:                    ax.text(0.5, 0.55, "MISSING", ha="center", va="center",                            fontsize=8, transform=ax.transAxes)                    ax.text(0.5, 0.35, f"{dataset}\n{pair_folder}\nL{layer} H{head}",                            ha="center", va="center", fontsize=6,                            transform=ax.transAxes, wrap=True)                else:                    img = load_image(p)                    if img is None:                        ax.text(0.5, 0.55, "BAD IMG", ha="center", va="center",                                fontsize=8, transform=ax.transAxes)                        ax.text(0.5, 0.35, str(p), ha="center", va="center",                                fontsize=6, transform=ax.transAxes, wrap=True)                    else:                        ax.imshow(img)                # annotate sanity mismatches on top of whatever is shown                if mismatch_note is not None:                    ax.text(                        0.5, 0.10,                        f"MISMATCH\n{mismatch_note}",                        ha="center", va="center",                        fontsize=7,                        transform=ax.transAxes,                        wrap=True                    )            if r == 0:                ax.set_title(COL_HEADERS[c], fontsize=10, pad=2)    fig.subplots_adjust(        left=0.08,        right=0.995,        top=0.98,        bottom=0.02,        wspace=0.02,        hspace=0.02    )    fig.canvas.draw()    for r, (layer, head) in enumerate(HEAD_LAYER_PLOTS):        pos = axes[r, 0].get_position()        y = 0.5 * (pos.y0 + pos.y1)        x = pos.x0 - 0.01        fig.text(x, y, f"L{layer}, H{head}", ha="right", va="center", fontsize=10)    out_png.parent.mkdir(parents=True, exist_ok=True)    fig.savefig(out_png, dpi=600, bbox_inches="tight", pad_inches=0.02)    return figdef main():    OUT_DIR.mkdir(parents=True, exist_ok=True)    OUT_PDF.parent.mkdir(parents=True, exist_ok=True)    # Load per_case.csv label maps once per dataset    label_maps = {        "with_binding": load_per_case_labels("with_binding"),        "without_binding": load_per_case_labels("without_binding"),    }    pdf = PdfPages(OUT_PDF)    try:        for i, item in enumerate(EXAMPLE_SERIES):            name = item.get("name", f"set_{i:02d}")            examples = item["examples"]            issues = sanity_check_examples(examples, label_maps)            if issues:                msg = "\n".join(issues)                if STRICT_SANITY:                    raise ValueError(f"Sanity check failed for {name}:\n{msg}")                else:                    print(f"[WARN] Sanity check issues for {name}:\n{msg}")            out_png = OUT_DIR / f"attention_panel_{name}.png"            fig = render_attention_panel(examples, out_png, label_maps)            pdf.savefig(fig)            plt.close(fig)            print(f"[OK] Saved: {out_png}")    finally:        pdf.close()        print(f"[OK] Saved combined PDF: {OUT_PDF}")if __name__ == "__main__":    main()